% This sample shows how quantization works based on luma component of the image

image_path = "data/mimuw-square-128.png";
show_images = false;
block_size = 8;

% Quantization table for luma. Generated by GIMP when
% saving JPG with quality=50.
luma_qt = [
   16  11  12  14  12  10  16  14;
   13  14  18  17  16  19  24  40;
   26  24  22  22  24  49  35  37;
   29  40  58  51  61  60  57  51;
   56  55  64  72  92  78  64  68;
   87  69  55  56  80 109  81  87;
   95  98 103 104 103  62  77 113;
  121 112 100 120  92 101 103  99
];

%% Load Octave Forge packages
pkg load image;
pkg load signal;

%% Load image and convert color space
img = imread(image_path);
image_size = size(img)(1:2);
if (mod(image_size, block_size) != [0 0])
  msg = sprintf(
    'Error: Image size \dx\d does not match \dx\d grid.',
    image_size(1), image_size(2),
    block_size, block_size
  );
  error(msg);
end

if (show_images)
  clf();
  imshow(img);
  waitfor(gcf);
end

img_ycbcr = rgb2ycbcr(img);
img_luma = 256*im2double(img_ycbcr(:, :, 1));
img_luma = img_luma(89:96,57:64);

if (show_images)
  clf();
  imshow(img_luma/256);
  waitfor(gcf);
end

%% DCT step
C = dctmtx(block_size);
forward_dct = @(block) (C * block * C');
dct_coeffs = blockproc(img_luma .- 128, block_size * [1 1], forward_dct);
if (show_images)
  clf();
  imshow((dct_coeffs+128)/256);
  waitfor(gcf);
end

%% Quantization
quantization = @(block) (round(block ./ luma_qt));
quantized_coeffs = blockproc(dct_coeffs, block_size * [1 1], quantization);

%% Dequantization
dequantization = @(block) (round(block .* luma_qt));
dequantized_coeffs = blockproc(quantized_coeffs, block_size * [1 1], dequantization);

if (show_images || true)
  clf();
  imshow((dequantized_coeffs+128)/256);
  waitfor(gcf);
end

% De-DCT
backward_dct = @(block) (C' * block * C);
dedct_coeffs = blockproc(dequantized_coeffs, block_size * [1 1], backward_dct);

unshifted_luma = round(dedct_coeffs .+ 128);
if (show_images || true)
  clf();
  imshow(unshifted_luma/256);
  waitfor(gcf);
end

